/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * This api document example is the Mainnet document, and the Testnet base URL is api.oasisscan.com/v2/testnet
 */
import {
  useQuery
} from '@tanstack/react-query'
import type {
  UseQueryOptions,
  QueryFunction,
  UseQueryResult,
  QueryKey
} from '@tanstack/react-query'
import accountDebondingUsingGETMutator from '../largePages';
import accountDelegationsUsingGETMutator from '../largePages';
import accountInfoUsingGETMutator from '../largePages';
import accountRewardExportUsingGETMutator from '../largePages';
import accountRewardUsingGETMutator from '../largePages';
import accountRewardStatsUsingGETMutator from '../largePages';
import stakingEventsUsingGETMutator from '../largePages';
import stakingEventUsingGETMutator from '../largePages';
import blockDetailGETMutator from '../largePages';
import latestBlocksUsingGETMutator from '../largePages';
import transactionMethodsUsingGETMutator from '../largePages';
import proposedBlocksUsingGETMutator from '../largePages';
import searchUsingGETMutator from '../largePages';
import transactionDetailUsingGETMutator from '../largePages';
import latestTransactionsUsingGETMutator from '../largePages';
import proposalListUsingGETMutator from '../largePages';
import proposalWithVotesUsingGETMutator from '../largePages';
import governanceVotesUsingGETMutator from '../largePages';
import healthUsingGETMutator from '../largePages';
import marketChartUsingGETMutator from '../largePages';
import marketDetailUsingGETMutator from '../largePages';
import networkStatusUsingGETMutator from '../largePages';
import runtimeListUsingGETMutator from '../largePages';
import runtimeRoundDetailUsingGETMutator from '../largePages';
import roundListUsingGETMutator from '../largePages';
import runtimeStatsUsingGETMutator from '../largePages';
import runtimeTransactionDetailUsingGETMutator from '../largePages';
import runtimeLatestTransactionsUsingGETMutator from '../largePages';
import networkTrendUsingGETMutator from '../largePages';
import validatorBlocksStatsUsingGETMutator from '../largePages';
import delegatorsUsingGETMutator from '../largePages';
import validatorEscrowEventUsingGETMutator from '../largePages';
import validatorEscrowStatsUsingGETMutator from '../largePages';
import validatorDetailUsingGETMutator from '../largePages';
import validatorsUsingGETMutator from '../largePages';
import validatorSignStatsUsingGETMutator from '../largePages';
export type ValidatorSignStatsUsingGETParams = {
address: string;
};

export type ValidatorsUsingGETParams = {
orderBy?: string;
sort?: string;
};

export type ValidatorDetailUsingGETParams = {
address: string;
};

export type ValidatorEscrowStatsUsingGETParams = {
address: string;
};

export type ValidatorEscrowEventUsingGETParams = {
address: string;
page?: number;
size?: number;
};

export type DelegatorsUsingGETParams = {
address: string;
page?: number;
size?: number;
};

export type ValidatorBlocksStatsUsingGETParams = {
address: string;
};

export type RuntimeLatestTransactionsUsingGETParams = {
id?: string;
address?: string;
round?: number;
page?: number;
size?: number;
};

export type RuntimeTransactionDetailUsingGETParams = {
id: string;
round: number;
hash: string;
};

export type RuntimeStatsUsingGETParams = {
id: string;
};

export type RoundListUsingGETParams = {
id: string;
page?: number;
size?: number;
};

export type RuntimeRoundDetailUsingGETParams = {
id: string;
round: number;
};

export type GovernanceVotesUsingGETParams = {
proposalId?: number;
validator?: string;
page?: number;
size?: number;
};

export type ProposalWithVotesUsingGETParams = {
id: number;
};

export type LatestTransactionsUsingGETParams = {
height?: number;
address?: string;
method?: string;
runtime?: boolean;
page?: number;
size?: number;
};

export type SearchUsingGETParams = {
key: string;
};

export type ProposedBlocksUsingGETParams = {
address?: string;
page?: number;
size?: number;
};

export type LatestBlocksUsingGETParams = {
page?: number;
size?: number;
};

export type StakingEventUsingGETParams = {
id: string;
};

export type StakingEventsUsingGETParams = {
address: string;
page?: number;
size?: number;
};

export type AccountRewardStatsUsingGETParams = {
account: string;
};

export type AccountRewardUsingGETParams = {
account: string;
page?: number;
size?: number;
};

export type AccountRewardExportUsingGETParams = {
account: string;
};

export type AccountDelegationsUsingGETParams = {
address: string;
all?: boolean;
page?: number;
size?: number;
};

export type AccountDebondingUsingGETParams = {
address: string;
page?: number;
size?: number;
};

export interface ValidatorSignStatsResponse {
  stats: ValidatorSignStatsInfo[];
  time: number[];
}

export interface ValidatorSignStatsRequest {
  address: string;
}

export interface ValidatorSignStatsInfo {
  dateTime: number;
  expected: number;
  actual: number;
}

export interface ValidatorRuntime {
  name: string;
  id: string;
  online: boolean;
}

export interface ValidatorListResponse {
  list: ValidatorInfo[];
  active: number;
  inactive: number;
  delegators: number;
}

export interface ValidatorListRequest {
  orderBy: string;
  sort: string;
}

export interface ValidatorInfoResponse {
  rank?: number;
  entityId?: string;
  entityAddress?: string;
  nodeId?: string;
  nodeAddress?: string;
  name?: string;
  icon?: string;
  website?: string;
  twitter?: string;
  keybase?: string;
  email?: string;
  description?: string;
  escrow?: string;
  escrowChange24?: string;
  escrowPercent?: number;
  balance?: string;
  totalShares?: string;
  signs?: number;
  proposals?: number;
  nonce?: number;
  score?: number;
  delegators?: number;
  nodes?: string[];
  uptime?: string;
  active?: boolean;
  commission?: number;
  bound?: Bound;
  rates?: Rate[];
  bounds?: Bound[];
  escrowSharesStatus?: EscrowStatus;
  escrowAmountStatus?: EscrowStatus;
  runtimes?: ValidatorRuntime[];
  status?: boolean;
}

export interface ValidatorInfoRequest {
  address: string;
}

export interface ValidatorInfo {
  rank: number;
  entityId: string;
  entityAddress: string;
  nodeId: string;
  nodeAddress: string;
  name: string;
  icon: string;
  website: string;
  twitter: string;
  keybase: string;
  email: string;
  description: string;
  escrow: string;
  escrowChange24: string;
  escrowPercent: number;
  balance: string;
  totalShares: string;
  signs: number;
  proposals: number;
  nonce: number;
  score: number;
  delegators: number;
  nodes?: string[];
  uptime: string;
  active: boolean;
  commission: number;
  bound?: Bound;
  rates: Rate[];
  bounds: Bound[];
  escrowSharesStatus?: EscrowStatus;
  escrowAmountStatus?: EscrowStatus;
  runtimes?: ValidatorRuntime[];
  status: boolean;
}

export interface ValidatorEscrowStatsResponse {
  list: ValidatorEscrowStatsInfo[];
}

export interface ValidatorEscrowStatsRequest {
  address: string;
}

export interface ValidatorEscrowStatsInfo {
  timestamp: number;
  escrow: string;
}

export interface ValidatorEscrowEventResponse {
  list: ChainTransactionListInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface ValidatorEscrowEventRequest {
  address: string;
  page: number;
  size: number;
}

export interface ValidatorBlocksStatsResponse {
  signs: ValidatorBlocksStatsInfo[];
  proposals: ValidatorBlocksStatsInfo[];
}

export interface ValidatorBlocksStatsRequest {
  address: string;
}

export interface ValidatorBlocksStatsInfo {
  height: number;
  block: boolean;
}

export interface RuntimeTransactionListResponse {
  list: RuntimeTransactionListInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface RuntimeTransactionListRequest {
  id?: string;
  address?: string;
  round?: number;
  page: number;
  size: number;
}

export interface RuntimeTransactionListInfo {
  runtimeId: string;
  txHash: string;
  round: number;
  result: boolean;
  timestamp: number;
  type: string;
}

export type RuntimeTransactionInfoResponseEvents = { [key: string]: any };

export interface RuntimeTransactionInfoRequest {
  id: string;
  round: number;
  hash: string;
}

export interface RuntimeTransactionEvmTx {
  hash: string;
  from: string;
  to: string;
  nonce: number;
  gasPrice: number;
  gasLimit: number;
  data: string;
  value: string;
}

export interface RuntimeTransactionEventError {
  code: number;
  module: string;
}

export interface RuntimeTransactionConsensusTx {
  method: string;
  from: string;
  to: string;
  amount: string;
  nonce: number;
}

export interface RuntimeTransactionInfoResponse {
  runtimeId: string;
  runtimeName: string;
  txHash: string;
  round: number;
  result: boolean;
  message: string;
  timestamp: number;
  type: string;
  ctx: RuntimeTransactionConsensusTx;
  etx: RuntimeTransactionEvmTx;
  events: RuntimeTransactionInfoResponseEvents;
}

export interface RuntimeStatsResponse {
  online: number;
  offline: number;
  list: RuntimeStatsInfo[];
}

export interface RuntimeStatsRequest {
  id: string;
}

export interface RuntimeStatsItem {
  elected: number;
  primary: number;
  backup: number;
  proposer: number;
}

export interface RuntimeStatsInfo {
  entityId: string;
  name: string;
  address: string;
  validator: boolean;
  icon: string;
  status: boolean;
  stats: RuntimeStatsItem;
}

export interface RuntimeRoundListResponse {
  list: RuntimeRoundInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface RuntimeRoundListRequest {
  id: string;
  page: number;
  size: number;
}

export interface RuntimeRoundInfoResponse {
  version?: number;
  runtimeId?: string;
  runtimeName?: string;
  round?: number;
  timestamp?: number;
  header_type?: number;
  previous_hash?: string;
  io_root?: string;
  state_root?: string;
  messages_hash?: string;
  next?: boolean;
}

export interface RuntimeRoundInfoRequest {
  id: string;
  round: number;
}

export interface RuntimeRoundInfo {
  version: number;
  runtimeId: string;
  runtimeName: string;
  round: number;
  timestamp: number;
  header_type: number;
  previous_hash: string;
  io_root: string;
  state_root: string;
  messages_hash: string;
  next: boolean;
}

export interface RuntimeListResponse {
  list: RuntimeListInfo[];
}

export interface RuntimeListRequest { [key: string]: any }

export interface RuntimeListInfo {
  runtimeId: string;
  name: string;
}

export interface Rate {
  start: number;
  rate: number;
}

export interface ProposalVote {
  proposalId: number;
  title: string;
  name: string;
  icon: string;
  address: string;
  vote: string;
  amount: string;
  percent: number;
}

export interface ProposalOption {
  name: string;
  amount: string;
  percent: number;
}

export interface Page {
  page: number;
  size: number;
  maxPage: number;
  totalSize: number;
}

export interface NetworkTrendResponse {
  tx: Chart[];
  escrow: Chart[];
}

export interface NetworkTrendRequest { [key: string]: any }

export interface NetworkStatusResponse {
  curHeight: number;
  curEpoch: number;
  totalTxs: number;
  totalEscrow: string;
  activeValidator: number;
  totalDelegator: number;
}

export interface NetworkStatusRequest { [key: string]: any }

export interface MarketInfoResponse {
  price: number;
  priceChangePct24h: number;
  rank: number;
  marketCap: number;
  marketCapChangePct24h: number;
  volume: number;
  volumeChangePct24h: number;
}

export interface MarketInfoRequest { [key: string]: any }

export interface MarketChartResponse {
  price: Chart[];
  marketCap: Chart[];
  volume: Chart[];
}

export interface MarketChartRequest { [key: string]: any }

export interface HealthResponse { [key: string]: any }

export interface HealthRequest { [key: string]: any }

export interface GovernanceVotesResponse {
  list: ProposalVote[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface GovernanceVotesRequest {
  proposalId?: number;
  validator?: string;
  page: number;
  size: number;
}

export interface GovernanceProposalWithVotesResponse {
  options: ProposalOption[];
  votes: ProposalVote[];
}

export interface GovernanceProposalWithVotesRequest {
  id: number;
}

export interface GovernanceProposalListResponse {
  list: GovernanceProposalInfo[];
}

export interface GovernanceProposalListRequest { [key: string]: any }

export interface GovernanceProposalInfo {
  id: number;
  title: string;
  type: string;
  submitter: string;
  state: string;
  deposit: string;
  created_at: number;
  closed_at: number;
  created_time: number;
  closed_time: number;
}

export interface EscrowStatus {
  self: string;
  other: string;
  total: string;
}

export interface DelegatorsResponse {
  list: DelegatorsInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface DelegatorsRequest {
  address: string;
  page: number;
  size: number;
}

export interface DelegatorsInfo {
  address: string;
  amount: string;
  shares: string;
  percent: number;
  self: boolean;
}

export interface Chart {
  key: string;
  value: string;
}

export interface ChainTransactionsResponse {
  list: ChainTransactionListInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface ChainTransactionsRequest {
  height?: number;
  address?: string;
  method?: string;
  runtime: boolean;
  page: number;
  size: number;
}

export interface ChainTransactionListInfo {
  txType: string;
  txHash?: string;
  height?: number;
  method?: string;
  fee?: string;
  amount?: string;
  shares?: string;
  add?: boolean;
  timestamp?: number;
  time?: number;
  status?: boolean;
  from?: string;
  to?: string;
  runtimeId?: string;
  runtimeName?: string;
  round?: number;
  result?: boolean;
  type?: string;
}

export interface ChainTransactionInfoResponse {
  txHash: string;
  timestamp: number;
  time: number;
  height: number;
  fee: string;
  nonce: number;
  method: string;
  from: string;
  to: string;
  amount: string;
  raw: string;
  status: boolean;
  errorMessage: string;
}

export interface ChainTransactionInfoRequest { [key: string]: any }

export interface ChainSearchResponse {
  key: string;
  type: string;
  result: string;
}

export interface ChainSearchRequest {
  key: string;
}

export interface ChainProposedBlocksResponse {
  list: ChainBlockInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface ChainProposedBlocksRequest {
  address?: string;
  page: number;
  size: number;
}

export interface ChainMethodsResponse {
  list: string[];
}

export interface ChainMethodsRequest { [key: string]: any }

export interface ChainBlocksResponse {
  list: ChainBlockInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface ChainBlocksRequest {
  page: number;
  size: number;
}

export interface ChainBlockInfoResponse {
  height?: number;
  epoch?: number;
  timestamp?: number;
  time?: number;
  hash?: string;
  txs?: number;
  entityAddress?: string;
  name?: string;
}

export interface ChainBlockInfoRequest { [key: string]: any }

export interface ChainBlockInfo {
  height: number;
  epoch: number;
  timestamp: number;
  time: number;
  hash: string;
  txs: number;
  entityAddress: string;
  name: string;
}

export interface Bound {
  start: number;
  min: number;
  max: number;
}

export interface AccountStakingEventsResponse {
  list: AccountStakingEventsInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface AccountStakingEventsRequest {
  address: string;
  page: number;
  size: number;
}

export type AccountStakingEventsInfoResponseAllowanceChange = { [key: string]: any };

export type AccountStakingEventsInfoResponseEscrow = { [key: string]: any };

export type AccountStakingEventsInfoResponseBurn = { [key: string]: any };

export type AccountStakingEventsInfoResponseTransafer = { [key: string]: any };

export interface AccountStakingEventsInfoResponse {
  height: number;
  txHash: string;
  kind: string;
  timestamp: number;
  transafer?: AccountStakingEventsInfoResponseTransafer;
  burn?: AccountStakingEventsInfoResponseBurn;
  escrow?: AccountStakingEventsInfoResponseEscrow;
  allowanceChange?: AccountStakingEventsInfoResponseAllowanceChange;
}

export interface AccountStakingEventsInfoRequest {
  id: string;
}

export interface AccountStakingEventsInfo {
  id: string;
  height: number;
  txHash: string;
  kind: string;
}

export type AccountRewardStatsResponseStats = {[key: string]: AccountRewardStatsInfo};

export interface AccountRewardStatsResponse {
  stats: AccountRewardStatsResponseStats;
  time: number[];
}

export interface AccountRewardStatsRequest {
  account: string;
}

export interface AccountRewardStatsItem {
  dateTime: number;
  reward: string;
}

export interface AccountRewardStatsInfo {
  validatorName: string;
  rewardList: AccountRewardStatsItem[];
  total: string;
}

export interface AccountRewardResponse {
  list: AccountRewardInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface AccountRewardRequest {
  account: string;
  page: number;
  size: number;
}

export interface AccountRewardInfo {
  validatorAddress: string;
  validatorName: string;
  validatorIcon: string;
  epoch: number;
  timestamp: number;
  reward: string;
}

export interface AccountRewardExportResponse { [key: string]: any }

export interface AccountRewardExportRequest {
  account: string;
}

export interface AccountInfoResponse {
  address: string;
  available: string;
  escrow: string;
  debonding: string;
  total: string;
  nonce: number;
  allowances: AccountAllowance[];
}

export interface AccountInfoRequest { [key: string]: any }

export interface AccountDelegationsResponse {
  list: AccountDelegationsInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface AccountDelegationsRequest {
  address: string;
  all: boolean;
  page: number;
  size: number;
}

export interface AccountDelegationsInfo {
  validatorAddress: string;
  validatorName: string;
  icon: string;
  entityAddress: string;
  shares: string;
  amount: string;
  active: boolean;
}

export interface AccountDebondingResponse {
  list: AccountDebondingInfo[];
  page?: number;
  size?: number;
  maxPage?: number;
  totalSize?: number;
}

export interface AccountDebondingRequest {
  address: string;
  page: number;
  size: number;
}

export interface AccountDebondingInfo {
  validatorAddress: string;
  validatorName: string;
  icon: string;
  shares: string;
  debondEnd: number;
  epochLeft: number;
}

export interface AccountAllowance {
  address: string;
  amount: string;
}



type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

export const accountDebondingUsingGET = (
    params: AccountDebondingUsingGETParams,
 options?: SecondParameter<typeof accountDebondingUsingGETMutator>,signal?: AbortSignal
) => {
      return accountDebondingUsingGETMutator<AccountDebondingResponse>(
      {url: `/account/debonding`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getAccountDebondingUsingGETQueryKey = (params: AccountDebondingUsingGETParams,) => [`/account/debonding`, ...(params ? [params]: [])] as const;
  

    
export const getAccountDebondingUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountDebondingUsingGET>>, TError = unknown>(params: AccountDebondingUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountDebondingUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountDebondingUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountDebondingUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountDebondingUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountDebondingUsingGET>>> = ({ signal }) => accountDebondingUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AccountDebondingUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountDebondingUsingGET>>>
export type AccountDebondingUsingGETQueryError = unknown

export const useAccountDebondingUsingGET = <TData = Awaited<ReturnType<typeof accountDebondingUsingGET>>, TError = unknown>(
 params: AccountDebondingUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountDebondingUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountDebondingUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountDebondingUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const accountDelegationsUsingGET = (
    params: AccountDelegationsUsingGETParams,
 options?: SecondParameter<typeof accountDelegationsUsingGETMutator>,signal?: AbortSignal
) => {
      return accountDelegationsUsingGETMutator<AccountDelegationsResponse>(
      {url: `/account/delegations`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getAccountDelegationsUsingGETQueryKey = (params: AccountDelegationsUsingGETParams,) => [`/account/delegations`, ...(params ? [params]: [])] as const;
  

    
export const getAccountDelegationsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountDelegationsUsingGET>>, TError = unknown>(params: AccountDelegationsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountDelegationsUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountDelegationsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountDelegationsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountDelegationsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountDelegationsUsingGET>>> = ({ signal }) => accountDelegationsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AccountDelegationsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountDelegationsUsingGET>>>
export type AccountDelegationsUsingGETQueryError = unknown

export const useAccountDelegationsUsingGET = <TData = Awaited<ReturnType<typeof accountDelegationsUsingGET>>, TError = unknown>(
 params: AccountDelegationsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountDelegationsUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountDelegationsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountDelegationsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const accountInfoUsingGET = (
    address: string,
 options?: SecondParameter<typeof accountInfoUsingGETMutator>,signal?: AbortSignal
) => {
      return accountInfoUsingGETMutator<AccountInfoResponse>(
      {url: `/account/info/${address}`, method: 'get', signal
    },
      options);
    }
  

export const getAccountInfoUsingGETQueryKey = (address: string,) => [`/account/info/${address}`] as const;
  

    
export const getAccountInfoUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountInfoUsingGET>>, TError = unknown>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountInfoUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountInfoUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountInfoUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountInfoUsingGETQueryKey(address);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountInfoUsingGET>>> = ({ signal }) => accountInfoUsingGET(address, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions}}

export type AccountInfoUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountInfoUsingGET>>>
export type AccountInfoUsingGETQueryError = unknown

export const useAccountInfoUsingGET = <TData = Awaited<ReturnType<typeof accountInfoUsingGET>>, TError = unknown>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountInfoUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountInfoUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountInfoUsingGETQueryOptions(address,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const accountRewardExportUsingGET = (
    params: AccountRewardExportUsingGETParams,
 options?: SecondParameter<typeof accountRewardExportUsingGETMutator>,signal?: AbortSignal
) => {
      return accountRewardExportUsingGETMutator<AccountRewardExportResponse>(
      {url: `/account/reward/export`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getAccountRewardExportUsingGETQueryKey = (params: AccountRewardExportUsingGETParams,) => [`/account/reward/export`, ...(params ? [params]: [])] as const;
  

    
export const getAccountRewardExportUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountRewardExportUsingGET>>, TError = unknown>(params: AccountRewardExportUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardExportUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardExportUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountRewardExportUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountRewardExportUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountRewardExportUsingGET>>> = ({ signal }) => accountRewardExportUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AccountRewardExportUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountRewardExportUsingGET>>>
export type AccountRewardExportUsingGETQueryError = unknown

export const useAccountRewardExportUsingGET = <TData = Awaited<ReturnType<typeof accountRewardExportUsingGET>>, TError = unknown>(
 params: AccountRewardExportUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardExportUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardExportUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountRewardExportUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const accountRewardUsingGET = (
    params: AccountRewardUsingGETParams,
 options?: SecondParameter<typeof accountRewardUsingGETMutator>,signal?: AbortSignal
) => {
      return accountRewardUsingGETMutator<AccountRewardResponse>(
      {url: `/account/reward/list`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getAccountRewardUsingGETQueryKey = (params: AccountRewardUsingGETParams,) => [`/account/reward/list`, ...(params ? [params]: [])] as const;
  

    
export const getAccountRewardUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountRewardUsingGET>>, TError = unknown>(params: AccountRewardUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountRewardUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountRewardUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountRewardUsingGET>>> = ({ signal }) => accountRewardUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AccountRewardUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountRewardUsingGET>>>
export type AccountRewardUsingGETQueryError = unknown

export const useAccountRewardUsingGET = <TData = Awaited<ReturnType<typeof accountRewardUsingGET>>, TError = unknown>(
 params: AccountRewardUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountRewardUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const accountRewardStatsUsingGET = (
    params: AccountRewardStatsUsingGETParams,
 options?: SecondParameter<typeof accountRewardStatsUsingGETMutator>,signal?: AbortSignal
) => {
      return accountRewardStatsUsingGETMutator<AccountRewardStatsResponse>(
      {url: `/account/reward/stats`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getAccountRewardStatsUsingGETQueryKey = (params: AccountRewardStatsUsingGETParams,) => [`/account/reward/stats`, ...(params ? [params]: [])] as const;
  

    
export const getAccountRewardStatsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof accountRewardStatsUsingGET>>, TError = unknown>(params: AccountRewardStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardStatsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof accountRewardStatsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAccountRewardStatsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof accountRewardStatsUsingGET>>> = ({ signal }) => accountRewardStatsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type AccountRewardStatsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof accountRewardStatsUsingGET>>>
export type AccountRewardStatsUsingGETQueryError = unknown

export const useAccountRewardStatsUsingGET = <TData = Awaited<ReturnType<typeof accountRewardStatsUsingGET>>, TError = unknown>(
 params: AccountRewardStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof accountRewardStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof accountRewardStatsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getAccountRewardStatsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const stakingEventsUsingGET = (
    params: StakingEventsUsingGETParams,
 options?: SecondParameter<typeof stakingEventsUsingGETMutator>,signal?: AbortSignal
) => {
      return stakingEventsUsingGETMutator<AccountStakingEventsResponse>(
      {url: `/account/staking/events`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getStakingEventsUsingGETQueryKey = (params: StakingEventsUsingGETParams,) => [`/account/staking/events`, ...(params ? [params]: [])] as const;
  

    
export const getStakingEventsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof stakingEventsUsingGET>>, TError = unknown>(params: StakingEventsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof stakingEventsUsingGET>>, TError, TData>, request?: SecondParameter<typeof stakingEventsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof stakingEventsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStakingEventsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof stakingEventsUsingGET>>> = ({ signal }) => stakingEventsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type StakingEventsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof stakingEventsUsingGET>>>
export type StakingEventsUsingGETQueryError = unknown

export const useStakingEventsUsingGET = <TData = Awaited<ReturnType<typeof stakingEventsUsingGET>>, TError = unknown>(
 params: StakingEventsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof stakingEventsUsingGET>>, TError, TData>, request?: SecondParameter<typeof stakingEventsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getStakingEventsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const stakingEventUsingGET = (
    params: StakingEventUsingGETParams,
 options?: SecondParameter<typeof stakingEventUsingGETMutator>,signal?: AbortSignal
) => {
      return stakingEventUsingGETMutator<AccountStakingEventsInfoResponse>(
      {url: `/account/staking/events/info`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getStakingEventUsingGETQueryKey = (params: StakingEventUsingGETParams,) => [`/account/staking/events/info`, ...(params ? [params]: [])] as const;
  

    
export const getStakingEventUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof stakingEventUsingGET>>, TError = unknown>(params: StakingEventUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof stakingEventUsingGET>>, TError, TData>, request?: SecondParameter<typeof stakingEventUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof stakingEventUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStakingEventUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof stakingEventUsingGET>>> = ({ signal }) => stakingEventUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type StakingEventUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof stakingEventUsingGET>>>
export type StakingEventUsingGETQueryError = unknown

export const useStakingEventUsingGET = <TData = Awaited<ReturnType<typeof stakingEventUsingGET>>, TError = unknown>(
 params: StakingEventUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof stakingEventUsingGET>>, TError, TData>, request?: SecondParameter<typeof stakingEventUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getStakingEventUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const blockDetailGET = (
    height: string,
 options?: SecondParameter<typeof blockDetailGETMutator>,signal?: AbortSignal
) => {
      return blockDetailGETMutator<ChainBlockInfoResponse>(
      {url: `/chain/block/${height}`, method: 'get', signal
    },
      options);
    }
  

export const getBlockDetailGETQueryKey = (height: string,) => [`/chain/block/${height}`] as const;
  

    
export const getBlockDetailGETQueryOptions = <TData = Awaited<ReturnType<typeof blockDetailGET>>, TError = unknown>(height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof blockDetailGET>>, TError, TData>, request?: SecondParameter<typeof blockDetailGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof blockDetailGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBlockDetailGETQueryKey(height);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof blockDetailGET>>> = ({ signal }) => blockDetailGET(height, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(height), ...queryOptions}}

export type BlockDetailGETQueryResult = NonNullable<Awaited<ReturnType<typeof blockDetailGET>>>
export type BlockDetailGETQueryError = unknown

export const useBlockDetailGET = <TData = Awaited<ReturnType<typeof blockDetailGET>>, TError = unknown>(
 height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof blockDetailGET>>, TError, TData>, request?: SecondParameter<typeof blockDetailGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getBlockDetailGETQueryOptions(height,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const latestBlocksUsingGET = (
    params: LatestBlocksUsingGETParams,
 options?: SecondParameter<typeof latestBlocksUsingGETMutator>,signal?: AbortSignal
) => {
      return latestBlocksUsingGETMutator<ChainBlocksResponse>(
      {url: `/chain/blocks`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getLatestBlocksUsingGETQueryKey = (params: LatestBlocksUsingGETParams,) => [`/chain/blocks`, ...(params ? [params]: [])] as const;
  

    
export const getLatestBlocksUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof latestBlocksUsingGET>>, TError = unknown>(params: LatestBlocksUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof latestBlocksUsingGET>>, TError, TData>, request?: SecondParameter<typeof latestBlocksUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof latestBlocksUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLatestBlocksUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof latestBlocksUsingGET>>> = ({ signal }) => latestBlocksUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type LatestBlocksUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof latestBlocksUsingGET>>>
export type LatestBlocksUsingGETQueryError = unknown

export const useLatestBlocksUsingGET = <TData = Awaited<ReturnType<typeof latestBlocksUsingGET>>, TError = unknown>(
 params: LatestBlocksUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof latestBlocksUsingGET>>, TError, TData>, request?: SecondParameter<typeof latestBlocksUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLatestBlocksUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const transactionMethodsUsingGET = (
    
 options?: SecondParameter<typeof transactionMethodsUsingGETMutator>,signal?: AbortSignal
) => {
      return transactionMethodsUsingGETMutator<ChainMethodsResponse>(
      {url: `/chain/methods`, method: 'get', signal
    },
      options);
    }
  

export const getTransactionMethodsUsingGETQueryKey = () => [`/chain/methods`] as const;
  

    
export const getTransactionMethodsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof transactionMethodsUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionMethodsUsingGET>>, TError, TData>, request?: SecondParameter<typeof transactionMethodsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof transactionMethodsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionMethodsUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionMethodsUsingGET>>> = ({ signal }) => transactionMethodsUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type TransactionMethodsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof transactionMethodsUsingGET>>>
export type TransactionMethodsUsingGETQueryError = unknown

export const useTransactionMethodsUsingGET = <TData = Awaited<ReturnType<typeof transactionMethodsUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionMethodsUsingGET>>, TError, TData>, request?: SecondParameter<typeof transactionMethodsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTransactionMethodsUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const proposedBlocksUsingGET = (
    params: ProposedBlocksUsingGETParams,
 options?: SecondParameter<typeof proposedBlocksUsingGETMutator>,signal?: AbortSignal
) => {
      return proposedBlocksUsingGETMutator<ChainProposedBlocksResponse>(
      {url: `/chain/proposedblocks`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getProposedBlocksUsingGETQueryKey = (params: ProposedBlocksUsingGETParams,) => [`/chain/proposedblocks`, ...(params ? [params]: [])] as const;
  

    
export const getProposedBlocksUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof proposedBlocksUsingGET>>, TError = unknown>(params: ProposedBlocksUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposedBlocksUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposedBlocksUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof proposedBlocksUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProposedBlocksUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof proposedBlocksUsingGET>>> = ({ signal }) => proposedBlocksUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ProposedBlocksUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof proposedBlocksUsingGET>>>
export type ProposedBlocksUsingGETQueryError = unknown

export const useProposedBlocksUsingGET = <TData = Awaited<ReturnType<typeof proposedBlocksUsingGET>>, TError = unknown>(
 params: ProposedBlocksUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposedBlocksUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposedBlocksUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getProposedBlocksUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const searchUsingGET = (
    params: SearchUsingGETParams,
 options?: SecondParameter<typeof searchUsingGETMutator>,signal?: AbortSignal
) => {
      return searchUsingGETMutator<ChainSearchResponse>(
      {url: `/chain/search`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getSearchUsingGETQueryKey = (params: SearchUsingGETParams,) => [`/chain/search`, ...(params ? [params]: [])] as const;
  

    
export const getSearchUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof searchUsingGET>>, TError = unknown>(params: SearchUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsingGET>>, TError, TData>, request?: SecondParameter<typeof searchUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof searchUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUsingGET>>> = ({ signal }) => searchUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SearchUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof searchUsingGET>>>
export type SearchUsingGETQueryError = unknown

export const useSearchUsingGET = <TData = Awaited<ReturnType<typeof searchUsingGET>>, TError = unknown>(
 params: SearchUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUsingGET>>, TError, TData>, request?: SecondParameter<typeof searchUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSearchUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const transactionDetailUsingGET = (
    hash: string,
 options?: SecondParameter<typeof transactionDetailUsingGETMutator>,signal?: AbortSignal
) => {
      return transactionDetailUsingGETMutator<ChainTransactionInfoResponse>(
      {url: `/chain/transaction/${hash}`, method: 'get', signal
    },
      options);
    }
  

export const getTransactionDetailUsingGETQueryKey = (hash: string,) => [`/chain/transaction/${hash}`] as const;
  

    
export const getTransactionDetailUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof transactionDetailUsingGET>>, TError = unknown>(hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof transactionDetailUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof transactionDetailUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getTransactionDetailUsingGETQueryKey(hash);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionDetailUsingGET>>> = ({ signal }) => transactionDetailUsingGET(hash, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(hash), ...queryOptions}}

export type TransactionDetailUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof transactionDetailUsingGET>>>
export type TransactionDetailUsingGETQueryError = unknown

export const useTransactionDetailUsingGET = <TData = Awaited<ReturnType<typeof transactionDetailUsingGET>>, TError = unknown>(
 hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof transactionDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof transactionDetailUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getTransactionDetailUsingGETQueryOptions(hash,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const latestTransactionsUsingGET = (
    params: LatestTransactionsUsingGETParams,
 options?: SecondParameter<typeof latestTransactionsUsingGETMutator>,signal?: AbortSignal
) => {
      return latestTransactionsUsingGETMutator<ChainTransactionsResponse>(
      {url: `/chain/transactions`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getLatestTransactionsUsingGETQueryKey = (params: LatestTransactionsUsingGETParams,) => [`/chain/transactions`, ...(params ? [params]: [])] as const;
  

    
export const getLatestTransactionsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof latestTransactionsUsingGET>>, TError = unknown>(params: LatestTransactionsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof latestTransactionsUsingGET>>, TError, TData>, request?: SecondParameter<typeof latestTransactionsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof latestTransactionsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLatestTransactionsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof latestTransactionsUsingGET>>> = ({ signal }) => latestTransactionsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type LatestTransactionsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof latestTransactionsUsingGET>>>
export type LatestTransactionsUsingGETQueryError = unknown

export const useLatestTransactionsUsingGET = <TData = Awaited<ReturnType<typeof latestTransactionsUsingGET>>, TError = unknown>(
 params: LatestTransactionsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof latestTransactionsUsingGET>>, TError, TData>, request?: SecondParameter<typeof latestTransactionsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getLatestTransactionsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const proposalListUsingGET = (
    
 options?: SecondParameter<typeof proposalListUsingGETMutator>,signal?: AbortSignal
) => {
      return proposalListUsingGETMutator<GovernanceProposalListResponse>(
      {url: `/governance/proposallist`, method: 'get', signal
    },
      options);
    }
  

export const getProposalListUsingGETQueryKey = () => [`/governance/proposallist`] as const;
  

    
export const getProposalListUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof proposalListUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposalListUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposalListUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof proposalListUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProposalListUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof proposalListUsingGET>>> = ({ signal }) => proposalListUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ProposalListUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof proposalListUsingGET>>>
export type ProposalListUsingGETQueryError = unknown

export const useProposalListUsingGET = <TData = Awaited<ReturnType<typeof proposalListUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposalListUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposalListUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getProposalListUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const proposalWithVotesUsingGET = (
    params: ProposalWithVotesUsingGETParams,
 options?: SecondParameter<typeof proposalWithVotesUsingGETMutator>,signal?: AbortSignal
) => {
      return proposalWithVotesUsingGETMutator<GovernanceProposalWithVotesResponse>(
      {url: `/governance/proposalwithvotes`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getProposalWithVotesUsingGETQueryKey = (params: ProposalWithVotesUsingGETParams,) => [`/governance/proposalwithvotes`, ...(params ? [params]: [])] as const;
  

    
export const getProposalWithVotesUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof proposalWithVotesUsingGET>>, TError = unknown>(params: ProposalWithVotesUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposalWithVotesUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposalWithVotesUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof proposalWithVotesUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProposalWithVotesUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof proposalWithVotesUsingGET>>> = ({ signal }) => proposalWithVotesUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ProposalWithVotesUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof proposalWithVotesUsingGET>>>
export type ProposalWithVotesUsingGETQueryError = unknown

export const useProposalWithVotesUsingGET = <TData = Awaited<ReturnType<typeof proposalWithVotesUsingGET>>, TError = unknown>(
 params: ProposalWithVotesUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof proposalWithVotesUsingGET>>, TError, TData>, request?: SecondParameter<typeof proposalWithVotesUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getProposalWithVotesUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const governanceVotesUsingGET = (
    params: GovernanceVotesUsingGETParams,
 options?: SecondParameter<typeof governanceVotesUsingGETMutator>,signal?: AbortSignal
) => {
      return governanceVotesUsingGETMutator<GovernanceVotesResponse>(
      {url: `/governance/votes`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getGovernanceVotesUsingGETQueryKey = (params: GovernanceVotesUsingGETParams,) => [`/governance/votes`, ...(params ? [params]: [])] as const;
  

    
export const getGovernanceVotesUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof governanceVotesUsingGET>>, TError = unknown>(params: GovernanceVotesUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof governanceVotesUsingGET>>, TError, TData>, request?: SecondParameter<typeof governanceVotesUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof governanceVotesUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGovernanceVotesUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof governanceVotesUsingGET>>> = ({ signal }) => governanceVotesUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type GovernanceVotesUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof governanceVotesUsingGET>>>
export type GovernanceVotesUsingGETQueryError = unknown

export const useGovernanceVotesUsingGET = <TData = Awaited<ReturnType<typeof governanceVotesUsingGET>>, TError = unknown>(
 params: GovernanceVotesUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof governanceVotesUsingGET>>, TError, TData>, request?: SecondParameter<typeof governanceVotesUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGovernanceVotesUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const healthUsingGET = (
    
 options?: SecondParameter<typeof healthUsingGETMutator>,signal?: AbortSignal
) => {
      return healthUsingGETMutator<HealthResponse>(
      {url: `/health`, method: 'get', signal
    },
      options);
    }
  

export const getHealthUsingGETQueryKey = () => [`/health`] as const;
  

    
export const getHealthUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof healthUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthUsingGET>>, TError, TData>, request?: SecondParameter<typeof healthUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof healthUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthUsingGET>>> = ({ signal }) => healthUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type HealthUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof healthUsingGET>>>
export type HealthUsingGETQueryError = unknown

export const useHealthUsingGET = <TData = Awaited<ReturnType<typeof healthUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthUsingGET>>, TError, TData>, request?: SecondParameter<typeof healthUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHealthUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const marketChartUsingGET = (
    
 options?: SecondParameter<typeof marketChartUsingGETMutator>,signal?: AbortSignal
) => {
      return marketChartUsingGETMutator<MarketChartResponse>(
      {url: `/market/chart`, method: 'get', signal
    },
      options);
    }
  

export const getMarketChartUsingGETQueryKey = () => [`/market/chart`] as const;
  

    
export const getMarketChartUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof marketChartUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof marketChartUsingGET>>, TError, TData>, request?: SecondParameter<typeof marketChartUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof marketChartUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarketChartUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof marketChartUsingGET>>> = ({ signal }) => marketChartUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type MarketChartUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof marketChartUsingGET>>>
export type MarketChartUsingGETQueryError = unknown

export const useMarketChartUsingGET = <TData = Awaited<ReturnType<typeof marketChartUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof marketChartUsingGET>>, TError, TData>, request?: SecondParameter<typeof marketChartUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getMarketChartUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const marketDetailUsingGET = (
    
 options?: SecondParameter<typeof marketDetailUsingGETMutator>,signal?: AbortSignal
) => {
      return marketDetailUsingGETMutator<MarketInfoResponse>(
      {url: `/market/info`, method: 'get', signal
    },
      options);
    }
  

export const getMarketDetailUsingGETQueryKey = () => [`/market/info`] as const;
  

    
export const getMarketDetailUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof marketDetailUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof marketDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof marketDetailUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof marketDetailUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getMarketDetailUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof marketDetailUsingGET>>> = ({ signal }) => marketDetailUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type MarketDetailUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof marketDetailUsingGET>>>
export type MarketDetailUsingGETQueryError = unknown

export const useMarketDetailUsingGET = <TData = Awaited<ReturnType<typeof marketDetailUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof marketDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof marketDetailUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getMarketDetailUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const networkStatusUsingGET = (
    
 options?: SecondParameter<typeof networkStatusUsingGETMutator>,signal?: AbortSignal
) => {
      return networkStatusUsingGETMutator<NetworkStatusResponse>(
      {url: `/network/status`, method: 'get', signal
    },
      options);
    }
  

export const getNetworkStatusUsingGETQueryKey = () => [`/network/status`] as const;
  

    
export const getNetworkStatusUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof networkStatusUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof networkStatusUsingGET>>, TError, TData>, request?: SecondParameter<typeof networkStatusUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof networkStatusUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNetworkStatusUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof networkStatusUsingGET>>> = ({ signal }) => networkStatusUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type NetworkStatusUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof networkStatusUsingGET>>>
export type NetworkStatusUsingGETQueryError = unknown

export const useNetworkStatusUsingGET = <TData = Awaited<ReturnType<typeof networkStatusUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof networkStatusUsingGET>>, TError, TData>, request?: SecondParameter<typeof networkStatusUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getNetworkStatusUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const runtimeListUsingGET = (
    
 options?: SecondParameter<typeof runtimeListUsingGETMutator>,signal?: AbortSignal
) => {
      return runtimeListUsingGETMutator<RuntimeListResponse>(
      {url: `/runtime/list`, method: 'get', signal
    },
      options);
    }
  

export const getRuntimeListUsingGETQueryKey = () => [`/runtime/list`] as const;
  

    
export const getRuntimeListUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof runtimeListUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeListUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeListUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof runtimeListUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRuntimeListUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof runtimeListUsingGET>>> = ({ signal }) => runtimeListUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RuntimeListUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof runtimeListUsingGET>>>
export type RuntimeListUsingGETQueryError = unknown

export const useRuntimeListUsingGET = <TData = Awaited<ReturnType<typeof runtimeListUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeListUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeListUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRuntimeListUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const runtimeRoundDetailUsingGET = (
    params: RuntimeRoundDetailUsingGETParams,
 options?: SecondParameter<typeof runtimeRoundDetailUsingGETMutator>,signal?: AbortSignal
) => {
      return runtimeRoundDetailUsingGETMutator<RuntimeRoundInfoResponse>(
      {url: `/runtime/round/info`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getRuntimeRoundDetailUsingGETQueryKey = (params: RuntimeRoundDetailUsingGETParams,) => [`/runtime/round/info`, ...(params ? [params]: [])] as const;
  

    
export const getRuntimeRoundDetailUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>, TError = unknown>(params: RuntimeRoundDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeRoundDetailUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRuntimeRoundDetailUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>> = ({ signal }) => runtimeRoundDetailUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RuntimeRoundDetailUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>>
export type RuntimeRoundDetailUsingGETQueryError = unknown

export const useRuntimeRoundDetailUsingGET = <TData = Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>, TError = unknown>(
 params: RuntimeRoundDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeRoundDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeRoundDetailUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRuntimeRoundDetailUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const roundListUsingGET = (
    params: RoundListUsingGETParams,
 options?: SecondParameter<typeof roundListUsingGETMutator>,signal?: AbortSignal
) => {
      return roundListUsingGETMutator<RuntimeRoundListResponse>(
      {url: `/runtime/round/list`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getRoundListUsingGETQueryKey = (params: RoundListUsingGETParams,) => [`/runtime/round/list`, ...(params ? [params]: [])] as const;
  

    
export const getRoundListUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof roundListUsingGET>>, TError = unknown>(params: RoundListUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof roundListUsingGET>>, TError, TData>, request?: SecondParameter<typeof roundListUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof roundListUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRoundListUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof roundListUsingGET>>> = ({ signal }) => roundListUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RoundListUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof roundListUsingGET>>>
export type RoundListUsingGETQueryError = unknown

export const useRoundListUsingGET = <TData = Awaited<ReturnType<typeof roundListUsingGET>>, TError = unknown>(
 params: RoundListUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof roundListUsingGET>>, TError, TData>, request?: SecondParameter<typeof roundListUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRoundListUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const runtimeStatsUsingGET = (
    params: RuntimeStatsUsingGETParams,
 options?: SecondParameter<typeof runtimeStatsUsingGETMutator>,signal?: AbortSignal
) => {
      return runtimeStatsUsingGETMutator<RuntimeStatsResponse>(
      {url: `/runtime/stats`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getRuntimeStatsUsingGETQueryKey = (params: RuntimeStatsUsingGETParams,) => [`/runtime/stats`, ...(params ? [params]: [])] as const;
  

    
export const getRuntimeStatsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof runtimeStatsUsingGET>>, TError = unknown>(params: RuntimeStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeStatsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof runtimeStatsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRuntimeStatsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof runtimeStatsUsingGET>>> = ({ signal }) => runtimeStatsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RuntimeStatsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof runtimeStatsUsingGET>>>
export type RuntimeStatsUsingGETQueryError = unknown

export const useRuntimeStatsUsingGET = <TData = Awaited<ReturnType<typeof runtimeStatsUsingGET>>, TError = unknown>(
 params: RuntimeStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeStatsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRuntimeStatsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const runtimeTransactionDetailUsingGET = (
    params: RuntimeTransactionDetailUsingGETParams,
 options?: SecondParameter<typeof runtimeTransactionDetailUsingGETMutator>,signal?: AbortSignal
) => {
      return runtimeTransactionDetailUsingGETMutator<RuntimeTransactionInfoResponse>(
      {url: `/runtime/transaction/info`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getRuntimeTransactionDetailUsingGETQueryKey = (params: RuntimeTransactionDetailUsingGETParams,) => [`/runtime/transaction/info`, ...(params ? [params]: [])] as const;
  

    
export const getRuntimeTransactionDetailUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>, TError = unknown>(params: RuntimeTransactionDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeTransactionDetailUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRuntimeTransactionDetailUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>> = ({ signal }) => runtimeTransactionDetailUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RuntimeTransactionDetailUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>>
export type RuntimeTransactionDetailUsingGETQueryError = unknown

export const useRuntimeTransactionDetailUsingGET = <TData = Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>, TError = unknown>(
 params: RuntimeTransactionDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeTransactionDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeTransactionDetailUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRuntimeTransactionDetailUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const runtimeLatestTransactionsUsingGET = (
    params: RuntimeLatestTransactionsUsingGETParams,
 options?: SecondParameter<typeof runtimeLatestTransactionsUsingGETMutator>,signal?: AbortSignal
) => {
      return runtimeLatestTransactionsUsingGETMutator<RuntimeTransactionListResponse>(
      {url: `/runtime/transaction/list`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getRuntimeLatestTransactionsUsingGETQueryKey = (params: RuntimeLatestTransactionsUsingGETParams,) => [`/runtime/transaction/list`, ...(params ? [params]: [])] as const;
  

    
export const getRuntimeLatestTransactionsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>, TError = unknown>(params: RuntimeLatestTransactionsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeLatestTransactionsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRuntimeLatestTransactionsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>> = ({ signal }) => runtimeLatestTransactionsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type RuntimeLatestTransactionsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>>
export type RuntimeLatestTransactionsUsingGETQueryError = unknown

export const useRuntimeLatestTransactionsUsingGET = <TData = Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>, TError = unknown>(
 params: RuntimeLatestTransactionsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof runtimeLatestTransactionsUsingGET>>, TError, TData>, request?: SecondParameter<typeof runtimeLatestTransactionsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getRuntimeLatestTransactionsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const networkTrendUsingGET = (
    
 options?: SecondParameter<typeof networkTrendUsingGETMutator>,signal?: AbortSignal
) => {
      return networkTrendUsingGETMutator<NetworkTrendResponse>(
      {url: `/trend`, method: 'get', signal
    },
      options);
    }
  

export const getNetworkTrendUsingGETQueryKey = () => [`/trend`] as const;
  

    
export const getNetworkTrendUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof networkTrendUsingGET>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof networkTrendUsingGET>>, TError, TData>, request?: SecondParameter<typeof networkTrendUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof networkTrendUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getNetworkTrendUsingGETQueryKey();

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof networkTrendUsingGET>>> = ({ signal }) => networkTrendUsingGET(requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type NetworkTrendUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof networkTrendUsingGET>>>
export type NetworkTrendUsingGETQueryError = unknown

export const useNetworkTrendUsingGET = <TData = Awaited<ReturnType<typeof networkTrendUsingGET>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof networkTrendUsingGET>>, TError, TData>, request?: SecondParameter<typeof networkTrendUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getNetworkTrendUsingGETQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorBlocksStatsUsingGET = (
    params: ValidatorBlocksStatsUsingGETParams,
 options?: SecondParameter<typeof validatorBlocksStatsUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorBlocksStatsUsingGETMutator<ValidatorBlocksStatsResponse>(
      {url: `/validator/blocksstats`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorBlocksStatsUsingGETQueryKey = (params: ValidatorBlocksStatsUsingGETParams,) => [`/validator/blocksstats`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorBlocksStatsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>, TError = unknown>(params: ValidatorBlocksStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorBlocksStatsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorBlocksStatsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>> = ({ signal }) => validatorBlocksStatsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorBlocksStatsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>>
export type ValidatorBlocksStatsUsingGETQueryError = unknown

export const useValidatorBlocksStatsUsingGET = <TData = Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>, TError = unknown>(
 params: ValidatorBlocksStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorBlocksStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorBlocksStatsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorBlocksStatsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const delegatorsUsingGET = (
    params: DelegatorsUsingGETParams,
 options?: SecondParameter<typeof delegatorsUsingGETMutator>,signal?: AbortSignal
) => {
      return delegatorsUsingGETMutator<DelegatorsResponse>(
      {url: `/validator/delegators`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getDelegatorsUsingGETQueryKey = (params: DelegatorsUsingGETParams,) => [`/validator/delegators`, ...(params ? [params]: [])] as const;
  

    
export const getDelegatorsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof delegatorsUsingGET>>, TError = unknown>(params: DelegatorsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof delegatorsUsingGET>>, TError, TData>, request?: SecondParameter<typeof delegatorsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof delegatorsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDelegatorsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof delegatorsUsingGET>>> = ({ signal }) => delegatorsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type DelegatorsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof delegatorsUsingGET>>>
export type DelegatorsUsingGETQueryError = unknown

export const useDelegatorsUsingGET = <TData = Awaited<ReturnType<typeof delegatorsUsingGET>>, TError = unknown>(
 params: DelegatorsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof delegatorsUsingGET>>, TError, TData>, request?: SecondParameter<typeof delegatorsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getDelegatorsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorEscrowEventUsingGET = (
    params: ValidatorEscrowEventUsingGETParams,
 options?: SecondParameter<typeof validatorEscrowEventUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorEscrowEventUsingGETMutator<ValidatorEscrowEventResponse>(
      {url: `/validator/escrowevent`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorEscrowEventUsingGETQueryKey = (params: ValidatorEscrowEventUsingGETParams,) => [`/validator/escrowevent`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorEscrowEventUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>, TError = unknown>(params: ValidatorEscrowEventUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorEscrowEventUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorEscrowEventUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>> = ({ signal }) => validatorEscrowEventUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorEscrowEventUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>>
export type ValidatorEscrowEventUsingGETQueryError = unknown

export const useValidatorEscrowEventUsingGET = <TData = Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>, TError = unknown>(
 params: ValidatorEscrowEventUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowEventUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorEscrowEventUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorEscrowEventUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorEscrowStatsUsingGET = (
    params: ValidatorEscrowStatsUsingGETParams,
 options?: SecondParameter<typeof validatorEscrowStatsUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorEscrowStatsUsingGETMutator<ValidatorEscrowStatsResponse>(
      {url: `/validator/escrowstats`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorEscrowStatsUsingGETQueryKey = (params: ValidatorEscrowStatsUsingGETParams,) => [`/validator/escrowstats`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorEscrowStatsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>, TError = unknown>(params: ValidatorEscrowStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorEscrowStatsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorEscrowStatsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>> = ({ signal }) => validatorEscrowStatsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorEscrowStatsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>>
export type ValidatorEscrowStatsUsingGETQueryError = unknown

export const useValidatorEscrowStatsUsingGET = <TData = Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>, TError = unknown>(
 params: ValidatorEscrowStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorEscrowStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorEscrowStatsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorEscrowStatsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorDetailUsingGET = (
    params: ValidatorDetailUsingGETParams,
 options?: SecondParameter<typeof validatorDetailUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorDetailUsingGETMutator<ValidatorInfoResponse>(
      {url: `/validator/info`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorDetailUsingGETQueryKey = (params: ValidatorDetailUsingGETParams,) => [`/validator/info`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorDetailUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorDetailUsingGET>>, TError = unknown>(params: ValidatorDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorDetailUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorDetailUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorDetailUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorDetailUsingGET>>> = ({ signal }) => validatorDetailUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorDetailUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorDetailUsingGET>>>
export type ValidatorDetailUsingGETQueryError = unknown

export const useValidatorDetailUsingGET = <TData = Awaited<ReturnType<typeof validatorDetailUsingGET>>, TError = unknown>(
 params: ValidatorDetailUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorDetailUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorDetailUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorDetailUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorsUsingGET = (
    params: ValidatorsUsingGETParams,
 options?: SecondParameter<typeof validatorsUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorsUsingGETMutator<ValidatorListResponse>(
      {url: `/validator/list`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorsUsingGETQueryKey = (params: ValidatorsUsingGETParams,) => [`/validator/list`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorsUsingGET>>, TError = unknown>(params: ValidatorsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorsUsingGET>>> = ({ signal }) => validatorsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorsUsingGET>>>
export type ValidatorsUsingGETQueryError = unknown

export const useValidatorsUsingGET = <TData = Awaited<ReturnType<typeof validatorsUsingGET>>, TError = unknown>(
 params: ValidatorsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const validatorSignStatsUsingGET = (
    params: ValidatorSignStatsUsingGETParams,
 options?: SecondParameter<typeof validatorSignStatsUsingGETMutator>,signal?: AbortSignal
) => {
      return validatorSignStatsUsingGETMutator<ValidatorSignStatsResponse>(
      {url: `/validator/signstats`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getValidatorSignStatsUsingGETQueryKey = (params: ValidatorSignStatsUsingGETParams,) => [`/validator/signstats`, ...(params ? [params]: [])] as const;
  

    
export const getValidatorSignStatsUsingGETQueryOptions = <TData = Awaited<ReturnType<typeof validatorSignStatsUsingGET>>, TError = unknown>(params: ValidatorSignStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorSignStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorSignStatsUsingGETMutator>}
): UseQueryOptions<Awaited<ReturnType<typeof validatorSignStatsUsingGET>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidatorSignStatsUsingGETQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof validatorSignStatsUsingGET>>> = ({ signal }) => validatorSignStatsUsingGET(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type ValidatorSignStatsUsingGETQueryResult = NonNullable<Awaited<ReturnType<typeof validatorSignStatsUsingGET>>>
export type ValidatorSignStatsUsingGETQueryError = unknown

export const useValidatorSignStatsUsingGET = <TData = Awaited<ReturnType<typeof validatorSignStatsUsingGET>>, TError = unknown>(
 params: ValidatorSignStatsUsingGETParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof validatorSignStatsUsingGET>>, TError, TData>, request?: SecondParameter<typeof validatorSignStatsUsingGETMutator>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getValidatorSignStatsUsingGETQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


